{"ast":null,"code":"import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nlet notificationSocket = null;\nlet globalNotificationHandler = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nlet reconnectDelay = 1000; // Start with 1 second delay\nlet isConnecting = false;\nfunction connectNotificationWebSocket() {\n  if (isConnecting) {\n    console.log('Notification WebSocket connection already in progress');\n    return;\n  }\n  if (notificationSocket && (notificationSocket.readyState === WebSocket.CONNECTING || notificationSocket.readyState === WebSocket.OPEN)) {\n    console.log('Notification WebSocket already connected or connecting');\n    return;\n  }\n  isConnecting = true;\n  try {\n    // Create WebSocket connection for notifications\n    notificationSocket = new WebSocket('ws://localhost:8080/ws/notifications');\n    notificationSocket.onopen = function (event) {\n      console.log('Connected to notification WebSocket');\n      isConnecting = false;\n      reconnectAttempts = 0;\n      reconnectDelay = 1000;\n    };\n    notificationSocket.onmessage = function (event) {\n      try {\n        const data = JSON.parse(event.data);\n        console.log('Received notification:', data);\n        if (data.type === 'new_notification' && globalNotificationHandler) {\n          // Only call the global handler once\n          try {\n            globalNotificationHandler(data.notification);\n          } catch (error) {\n            console.error('Error in global notification handler:', error);\n          }\n        }\n      } catch (error) {\n        console.error('Error parsing notification WebSocket message:', error);\n      }\n    };\n    notificationSocket.onclose = function (event) {\n      console.log('Notification WebSocket connection closed');\n      notificationSocket = null;\n      isConnecting = false;\n\n      // Attempt to reconnect if not manually closed\n      if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts && globalNotificationHandler) {\n        reconnectAttempts++;\n        console.log(`Attempting to reconnect notification WebSocket (${reconnectAttempts}/${maxReconnectAttempts}) in ${reconnectDelay}ms`);\n        setTimeout(() => {\n          connectNotificationWebSocket();\n        }, reconnectDelay);\n\n        // Exponential backoff\n        reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n      }\n    };\n    notificationSocket.onerror = function (error) {\n      console.error('Notification WebSocket error:', error);\n      isConnecting = false;\n    };\n  } catch (error) {\n    console.error('Failed to create notification WebSocket connection:', error);\n    isConnecting = false;\n  }\n}\nfunction disconnectNotificationWebSocket() {\n  if (notificationSocket) {\n    notificationSocket.close(1000, 'Manual disconnect');\n    notificationSocket = null;\n  }\n  globalNotificationHandler = null;\n  isConnecting = false;\n}\nfunction setGlobalNotificationHandler(handler) {\n  if (typeof handler !== 'function') {\n    console.error('Notification handler must be a function');\n    return;\n  }\n  console.log('Setting global notification handler');\n  globalNotificationHandler = handler;\n\n  // Connect WebSocket if not already connected\n  if (!notificationSocket || notificationSocket.readyState === WebSocket.CLOSED) {\n    connectNotificationWebSocket();\n  }\n}\nfunction removeGlobalNotificationHandler() {\n  console.log('Removing global notification handler');\n  globalNotificationHandler = null;\n\n  // Disconnect if no handler\n  if (!globalNotificationHandler) {\n    disconnectNotificationWebSocket();\n  }\n}\nfunction isConnected() {\n  return notificationSocket && notificationSocket.readyState === WebSocket.OPEN;\n}\n\n// Global notification manager\nlet activeComponents = new Set();\nlet latestComponent = null;\nfunction registerComponent(componentName) {\n  activeComponents.add(componentName);\n  latestComponent = componentName;\n  console.log(`Registered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\nfunction unregisterComponent(componentName) {\n  activeComponents.delete(componentName);\n  if (latestComponent === componentName) {\n    latestComponent = activeComponents.size > 0 ? Array.from(activeComponents)[activeComponents.size - 1] : null;\n  }\n  console.log(`Unregistered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\n\n// Component-specific handlers\nlet componentHandlers = new Map();\nfunction onNotification(componentName, handler) {\n  if (typeof handler !== 'function') {\n    console.error('Notification handler must be a function');\n    return;\n  }\n\n  // Register this component\n  registerComponent(componentName);\n  componentHandlers.set(componentName, handler);\n\n  // Set up global handler if not already set\n  if (!globalNotificationHandler) {\n    setGlobalNotificationHandler(notification => {\n      // Only call the handler for the latest (most recently mounted) component\n      if (latestComponent && componentHandlers.has(latestComponent)) {\n        const handler = componentHandlers.get(latestComponent);\n        try {\n          handler(notification);\n        } catch (error) {\n          console.error(`Error in notification handler for ${latestComponent}:`, error);\n        }\n      }\n    });\n  }\n}\nfunction removeNotificationHandler(componentName) {\n  unregisterComponent(componentName);\n  componentHandlers.delete(componentName);\n\n  // If no more components, disconnect\n  if (activeComponents.size === 0) {\n    removeGlobalNotificationHandler();\n  }\n}\n\n// Export notification WebSocket functions\nexport const notificationWebSocket = {\n  connect: connectNotificationWebSocket,\n  disconnect: disconnectNotificationWebSocket,\n  onNotification,\n  removeNotificationHandler,\n  isConnected\n};","map":{"version":3,"names":["notificationSocket","globalNotificationHandler","reconnectAttempts","maxReconnectAttempts","reconnectDelay","isConnecting","connectNotificationWebSocket","console","log","readyState","WebSocket","CONNECTING","OPEN","onopen","event","onmessage","data","JSON","parse","type","notification","error","onclose","code","setTimeout","Math","min","onerror","disconnectNotificationWebSocket","close","setGlobalNotificationHandler","handler","CLOSED","removeGlobalNotificationHandler","isConnected","activeComponents","Set","latestComponent","registerComponent","componentName","add","Array","from","unregisterComponent","delete","size","componentHandlers","Map","onNotification","set","has","get","removeNotificationHandler","notificationWebSocket","connect","disconnect"],"sources":["/Users/apple/Desktop/social-1/social-network/frontend/src/services/notificationWebSocket.js"],"sourcesContent":["let notificationSocket = null;\nlet globalNotificationHandler = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nlet reconnectDelay = 1000; // Start with 1 second delay\nlet isConnecting = false;\n\nfunction connectNotificationWebSocket() {\n    if (isConnecting) {\n        console.log('Notification WebSocket connection already in progress');\n        return;\n    }\n\n    if (notificationSocket && (notificationSocket.readyState === WebSocket.CONNECTING || notificationSocket.readyState === WebSocket.OPEN)) {\n        console.log('Notification WebSocket already connected or connecting');\n        return;\n    }\n\n    isConnecting = true;\n\n    try {\n        // Create WebSocket connection for notifications\n        notificationSocket = new WebSocket('ws://localhost:8080/ws/notifications');\n        \n        notificationSocket.onopen = function(event) {\n            console.log('Connected to notification WebSocket');\n            isConnecting = false;\n            reconnectAttempts = 0;\n            reconnectDelay = 1000;\n        };\n\n        notificationSocket.onmessage = function(event) {\n            try {\n                const data = JSON.parse(event.data);\n                console.log('Received notification:', data);\n                \n                if (data.type === 'new_notification' && globalNotificationHandler) {\n                    // Only call the global handler once\n                    try {\n                        globalNotificationHandler(data.notification);\n                    } catch (error) {\n                        console.error('Error in global notification handler:', error);\n                    }\n                }\n            } catch (error) {\n                console.error('Error parsing notification WebSocket message:', error);\n            }\n        };\n\n        notificationSocket.onclose = function(event) {\n            console.log('Notification WebSocket connection closed');\n            notificationSocket = null;\n            isConnecting = false;\n            \n            // Attempt to reconnect if not manually closed\n            if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts && globalNotificationHandler) {\n                reconnectAttempts++;\n                console.log(`Attempting to reconnect notification WebSocket (${reconnectAttempts}/${maxReconnectAttempts}) in ${reconnectDelay}ms`);\n                \n                setTimeout(() => {\n                    connectNotificationWebSocket();\n                }, reconnectDelay);\n                \n                // Exponential backoff\n                reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n            }\n        };\n\n        notificationSocket.onerror = function(error) {\n            console.error('Notification WebSocket error:', error);\n            isConnecting = false;\n        };\n\n    } catch (error) {\n        console.error('Failed to create notification WebSocket connection:', error);\n        isConnecting = false;\n    }\n}\n\nfunction disconnectNotificationWebSocket() {\n    if (notificationSocket) {\n        notificationSocket.close(1000, 'Manual disconnect');\n        notificationSocket = null;\n    }\n    globalNotificationHandler = null;\n    isConnecting = false;\n}\n\nfunction setGlobalNotificationHandler(handler) {\n    if (typeof handler !== 'function') {\n        console.error('Notification handler must be a function');\n        return;\n    }\n    \n    console.log('Setting global notification handler');\n    globalNotificationHandler = handler;\n    \n    // Connect WebSocket if not already connected\n    if (!notificationSocket || notificationSocket.readyState === WebSocket.CLOSED) {\n        connectNotificationWebSocket();\n    }\n}\n\nfunction removeGlobalNotificationHandler() {\n    console.log('Removing global notification handler');\n    globalNotificationHandler = null;\n    \n    // Disconnect if no handler\n    if (!globalNotificationHandler) {\n        disconnectNotificationWebSocket();\n    }\n}\n\nfunction isConnected() {\n    return notificationSocket && notificationSocket.readyState === WebSocket.OPEN;\n}\n\n// Global notification manager\nlet activeComponents = new Set();\nlet latestComponent = null;\n\nfunction registerComponent(componentName) {\n    activeComponents.add(componentName);\n    latestComponent = componentName;\n    console.log(`Registered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\n\nfunction unregisterComponent(componentName) {\n    activeComponents.delete(componentName);\n    if (latestComponent === componentName) {\n        latestComponent = activeComponents.size > 0 ? Array.from(activeComponents)[activeComponents.size - 1] : null;\n    }\n    console.log(`Unregistered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\n\n// Component-specific handlers\nlet componentHandlers = new Map();\n\nfunction onNotification(componentName, handler) {\n    if (typeof handler !== 'function') {\n        console.error('Notification handler must be a function');\n        return;\n    }\n    \n    // Register this component\n    registerComponent(componentName);\n    componentHandlers.set(componentName, handler);\n    \n    // Set up global handler if not already set\n    if (!globalNotificationHandler) {\n        setGlobalNotificationHandler((notification) => {\n            // Only call the handler for the latest (most recently mounted) component\n            if (latestComponent && componentHandlers.has(latestComponent)) {\n                const handler = componentHandlers.get(latestComponent);\n                try {\n                    handler(notification);\n                } catch (error) {\n                    console.error(`Error in notification handler for ${latestComponent}:`, error);\n                }\n            }\n        });\n    }\n}\n\nfunction removeNotificationHandler(componentName) {\n    unregisterComponent(componentName);\n    componentHandlers.delete(componentName);\n    \n    // If no more components, disconnect\n    if (activeComponents.size === 0) {\n        removeGlobalNotificationHandler();\n    }\n}\n\n// Export notification WebSocket functions\nexport const notificationWebSocket = {\n    connect: connectNotificationWebSocket,\n    disconnect: disconnectNotificationWebSocket,\n    onNotification,\n    removeNotificationHandler,\n    isConnected\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}