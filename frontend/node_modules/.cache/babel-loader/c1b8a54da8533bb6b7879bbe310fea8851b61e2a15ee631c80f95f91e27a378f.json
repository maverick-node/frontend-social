{"ast":null,"code":"import \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nlet notificationSocket = null;\nlet globalNotificationHandler = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nlet reconnectDelay = 1000;\nlet isConnecting = false;\nfunction connectNotificationWebSocket() {\n  if (isConnecting) {\n    console.log(\"Notification WebSocket connection already in progress\");\n    return;\n  }\n  if (notificationSocket && (notificationSocket.readyState === WebSocket.CONNECTING || notificationSocket.readyState === WebSocket.OPEN)) {\n    console.log(\"Notification WebSocket already connected or connecting\");\n    return;\n  }\n  isConnecting = true;\n  try {\n    notificationSocket = new WebSocket(\"ws://localhost:8080/ws/notifications\");\n    notificationSocket.onopen = function (event) {\n      console.log(\"Connected to notification WebSocket\");\n      isConnecting = false;\n      reconnectAttempts = 0;\n      reconnectDelay = 1000;\n    };\n    notificationSocket.onmessage = function (event) {\n      try {\n        const data = JSON.parse(event.data);\n        console.log(\"Received notification:\", data);\n        if (data.type === \"new_notification\" && globalNotificationHandler) {\n          try {\n            globalNotificationHandler(data.notification);\n          } catch (error) {\n            console.error(\"Error in global notification handler:\", error);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error parsing notification WebSocket message:\", error);\n      }\n    };\n    notificationSocket.onclose = function (event) {\n      console.log(\"Notification WebSocket connection closed\");\n      notificationSocket = null;\n      isConnecting = false;\n      if (event.code !== 1000 && reconnectAttempts < maxReconnectAttempts && globalNotificationHandler) {\n        reconnectAttempts++;\n        console.log(`Attempting to reconnect notification WebSocket (${reconnectAttempts}/${maxReconnectAttempts}) in ${reconnectDelay}ms`);\n        setTimeout(() => {\n          connectNotificationWebSocket();\n        }, reconnectDelay);\n        reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n      }\n    };\n    notificationSocket.onerror = function (error) {\n      console.error(\"Notification WebSocket error:\", error);\n      isConnecting = false;\n    };\n  } catch (error) {\n    console.error(\"Failed to create notification WebSocket connection:\", error);\n    isConnecting = false;\n  }\n}\nfunction disconnectNotificationWebSocket() {\n  if (notificationSocket) {\n    notificationSocket.close(1000, \"Manual disconnect\");\n    notificationSocket = null;\n  }\n  globalNotificationHandler = null;\n  isConnecting = false;\n}\nfunction setGlobalNotificationHandler(handler) {\n  if (typeof handler !== \"function\") {\n    console.error(\"Notification handler must be a function\");\n    return;\n  }\n  console.log(\"Setting global notification handler\");\n  globalNotificationHandler = handler;\n  if (!notificationSocket || notificationSocket.readyState === WebSocket.CLOSED) {\n    connectNotificationWebSocket();\n  }\n}\nfunction removeGlobalNotificationHandler() {\n  console.log(\"Removing global notification handler\");\n  globalNotificationHandler = null;\n  if (!globalNotificationHandler) {\n    disconnectNotificationWebSocket();\n  }\n}\nfunction isConnected() {\n  return notificationSocket && notificationSocket.readyState === WebSocket.OPEN;\n}\nlet activeComponents = new Set();\nlet latestComponent = null;\nfunction registerComponent(componentName) {\n  activeComponents.add(componentName);\n  latestComponent = componentName;\n  console.log(`Registered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\nfunction unregisterComponent(componentName) {\n  activeComponents.delete(componentName);\n  if (latestComponent === componentName) {\n    latestComponent = activeComponents.size > 0 ? Array.from(activeComponents)[activeComponents.size - 1] : null;\n  }\n  console.log(`Unregistered component: ${componentName}, Active components:`, Array.from(activeComponents));\n}\nlet componentHandlers = new Map();\nfunction onNotification(componentName, handler) {\n  if (typeof handler !== \"function\") {\n    console.error(\"Notification handler must be a function\");\n    return;\n  }\n  registerComponent(componentName);\n  componentHandlers.set(componentName, handler);\n  if (!globalNotificationHandler) {\n    setGlobalNotificationHandler(notification => {\n      if (latestComponent && componentHandlers.has(latestComponent)) {\n        const handler = componentHandlers.get(latestComponent);\n        try {\n          handler(notification);\n        } catch (error) {\n          console.error(`Error in notification handler for ${latestComponent}:`, error);\n        }\n      }\n    });\n  }\n}\nfunction removeNotificationHandler(componentName) {\n  unregisterComponent(componentName);\n  componentHandlers.delete(componentName);\n  if (activeComponents.size === 0) {\n    removeGlobalNotificationHandler();\n  }\n}\nexport const notificationWebSocket = {\n  connect: connectNotificationWebSocket,\n  disconnect: disconnectNotificationWebSocket,\n  onNotification,\n  removeNotificationHandler,\n  isConnected\n};","map":{"version":3,"names":["notificationSocket","globalNotificationHandler","reconnectAttempts","maxReconnectAttempts","reconnectDelay","isConnecting","connectNotificationWebSocket","console","log","readyState","WebSocket","CONNECTING","OPEN","onopen","event","onmessage","data","JSON","parse","type","notification","error","onclose","code","setTimeout","Math","min","onerror","disconnectNotificationWebSocket","close","setGlobalNotificationHandler","handler","CLOSED","removeGlobalNotificationHandler","isConnected","activeComponents","Set","latestComponent","registerComponent","componentName","add","Array","from","unregisterComponent","delete","size","componentHandlers","Map","onNotification","set","has","get","removeNotificationHandler","notificationWebSocket","connect","disconnect"],"sources":["/Users/apple/Desktop/social-1/social-network/frontend/src/services/notificationWebSocket.js"],"sourcesContent":["let notificationSocket = null;\nlet globalNotificationHandler = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nlet reconnectDelay = 1000;\nlet isConnecting = false;\n\nfunction connectNotificationWebSocket() {\n  if (isConnecting) {\n    console.log(\"Notification WebSocket connection already in progress\");\n    return;\n  }\n\n  if (\n    notificationSocket &&\n    (notificationSocket.readyState === WebSocket.CONNECTING ||\n      notificationSocket.readyState === WebSocket.OPEN)\n  ) {\n    console.log(\"Notification WebSocket already connected or connecting\");\n    return;\n  }\n\n  isConnecting = true;\n\n  try {\n    notificationSocket = new WebSocket(\"ws://localhost:8080/ws/notifications\");\n\n    notificationSocket.onopen = function (event) {\n      console.log(\"Connected to notification WebSocket\");\n      isConnecting = false;\n      reconnectAttempts = 0;\n      reconnectDelay = 1000;\n    };\n\n    notificationSocket.onmessage = function (event) {\n      try {\n        const data = JSON.parse(event.data);\n        console.log(\"Received notification:\", data);\n\n        if (data.type === \"new_notification\" && globalNotificationHandler) {\n          try {\n            globalNotificationHandler(data.notification);\n          } catch (error) {\n            console.error(\"Error in global notification handler:\", error);\n          }\n        }\n      } catch (error) {\n        console.error(\"Error parsing notification WebSocket message:\", error);\n      }\n    };\n\n    notificationSocket.onclose = function (event) {\n      console.log(\"Notification WebSocket connection closed\");\n      notificationSocket = null;\n      isConnecting = false;\n\n      if (\n        event.code !== 1000 &&\n        reconnectAttempts < maxReconnectAttempts &&\n        globalNotificationHandler\n      ) {\n        reconnectAttempts++;\n        console.log(\n          `Attempting to reconnect notification WebSocket (${reconnectAttempts}/${maxReconnectAttempts}) in ${reconnectDelay}ms`\n        );\n\n        setTimeout(() => {\n          connectNotificationWebSocket();\n        }, reconnectDelay);\n\n        reconnectDelay = Math.min(reconnectDelay * 2, 30000);\n      }\n    };\n\n    notificationSocket.onerror = function (error) {\n      console.error(\"Notification WebSocket error:\", error);\n      isConnecting = false;\n    };\n  } catch (error) {\n    console.error(\"Failed to create notification WebSocket connection:\", error);\n    isConnecting = false;\n  }\n}\n\nfunction disconnectNotificationWebSocket() {\n  if (notificationSocket) {\n    notificationSocket.close(1000, \"Manual disconnect\");\n    notificationSocket = null;\n  }\n  globalNotificationHandler = null;\n  isConnecting = false;\n}\n\nfunction setGlobalNotificationHandler(handler) {\n  if (typeof handler !== \"function\") {\n    console.error(\"Notification handler must be a function\");\n    return;\n  }\n\n  console.log(\"Setting global notification handler\");\n  globalNotificationHandler = handler;\n\n  if (\n    !notificationSocket ||\n    notificationSocket.readyState === WebSocket.CLOSED\n  ) {\n    connectNotificationWebSocket();\n  }\n}\n\nfunction removeGlobalNotificationHandler() {\n  console.log(\"Removing global notification handler\");\n  globalNotificationHandler = null;\n\n  if (!globalNotificationHandler) {\n    disconnectNotificationWebSocket();\n  }\n}\n\nfunction isConnected() {\n  return notificationSocket && notificationSocket.readyState === WebSocket.OPEN;\n}\n\nlet activeComponents = new Set();\nlet latestComponent = null;\n\nfunction registerComponent(componentName) {\n  activeComponents.add(componentName);\n  latestComponent = componentName;\n  console.log(\n    `Registered component: ${componentName}, Active components:`,\n    Array.from(activeComponents)\n  );\n}\n\nfunction unregisterComponent(componentName) {\n  activeComponents.delete(componentName);\n  if (latestComponent === componentName) {\n    latestComponent =\n      activeComponents.size > 0\n        ? Array.from(activeComponents)[activeComponents.size - 1]\n        : null;\n  }\n  console.log(\n    `Unregistered component: ${componentName}, Active components:`,\n    Array.from(activeComponents)\n  );\n}\n\nlet componentHandlers = new Map();\n\nfunction onNotification(componentName, handler) {\n  if (typeof handler !== \"function\") {\n    console.error(\"Notification handler must be a function\");\n    return;\n  }\n\n  registerComponent(componentName);\n  componentHandlers.set(componentName, handler);\n\n  if (!globalNotificationHandler) {\n    setGlobalNotificationHandler((notification) => {\n      if (latestComponent && componentHandlers.has(latestComponent)) {\n        const handler = componentHandlers.get(latestComponent);\n        try {\n          handler(notification);\n        } catch (error) {\n          console.error(\n            `Error in notification handler for ${latestComponent}:`,\n            error\n          );\n        }\n      }\n    });\n  }\n}\n\nfunction removeNotificationHandler(componentName) {\n  unregisterComponent(componentName);\n  componentHandlers.delete(componentName);\n\n  if (activeComponents.size === 0) {\n    removeGlobalNotificationHandler();\n  }\n}\n\nexport const notificationWebSocket = {\n  connect: connectNotificationWebSocket,\n  disconnect: disconnectNotificationWebSocket,\n  onNotification,\n  removeNotificationHandler,\n  isConnected,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}